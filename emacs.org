#+TITLE: Christian's Emacs configuration
#+STARTUP: content

* Christian's Emacs configuration
** Initialisation

   Inspired by [[https://github.com/sachac/.emacs.d/blob/gh-pages/Sacha.org][Sacha Chua's Emacs configuration]], I'm using a
   minimalistic =emacs.d/init.el= file to load an org mode document
   with elisp snippets embedded. org-babel extracts the snippets and
   evaluates the code. This is the content of my =init.el=:

#+begin_src emacs-lisp  :tangle no
(require 'cask "~/.cask/cask.el")
(cask-initialize)

(require 'org)
(require 'ob-tangle)

(org-babel-load-file (expand-file-name "~/.emacs.d/emacs.org"))
#+end_src

** Keymap for my shortcuts

#+begin_src emacs-lisp
  (defvar ck/keys-minor-mode-map (make-keymap) "ck/keys-minor-mode keymap.")
#+end_src

** Personal information

#+begin_src emacs-lisp
  (setq user-full-name "Christian Kruse"
        user-mail-address "cjk@defunct.ch")
#+end_src

** Emacs initialization

   I manage my package installations with the excellent [[http://cask.github.io/][Cask Package
   Manager]]. Therefore I additionally maintain a =Cask= file with all
   packages listed as dependencies. So I can easily install and update
   all packages via =cask install= and =cask update=. You can find my
   cask file at [[https://github.com/ckruse/Emacs.d/blob/master/Cask][github]].

#+begin_src emacs-lisp
(add-to-list 'load-path "~/.emacs.d/site-lisp")

(require 'use-package)
#+end_src

*** Byte-compile init files to speed things up on Emacs startup

    I restart Emacs round about once a week when I upgrade my
    packages. Thus it is nice to speed things up; byte-compiling elisp
    files does exactly this.


#+begin_src emacs-lisp
(defun ck/byte-recompile ()
  (interactive)
  (byte-recompile-directory "~/.emacs.d" 0)
  (byte-recompile-directory "~/emacs.d/site-lisp" 0))
#+end_src

*** is this os x?

#+begin_src emacs-lisp
  (defun ck/is-osx ()
      (or (featurep 'ns)
          (featurep 'mac)))
#+end_src

*** Start Emacs server

    I use =emacsclient= a lot to open files via command line (I
    aliased it to =ff= (=find-file=) and =ffn= (=find-file no
    wait=)). Thus start the Emacs server to be able to use that.

#+begin_src emacs-lisp
(load "server")
(unless (server-running-p)
  (server-start))
#+end_src

*** Toolbar, Menubar, scratch message, startup screen, etc

    As a beginner the bars may be useful but for me they just suck. So
    I disable them.

#+begin_src emacs-lisp
(setq initial-scratch-message nil)
(setq initial-major-mode 'fundamental-mode)

; remove ugly and sucking toolbar
(tooltip-mode -1)
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)

(setq inhibit-splash-screen t)
#+end_src

*** Autosave and backups

    I don't like the backup and autosave features of Emacs, thus I
    disable them.

#+begin_src emacs-lisp

(setq backup-inhibited t)
(setq-default backup-inhibited t)

(setq auto-save-default nil)
(setq-default auto-save-default nil)
(setq auto-save-list-file-prefix nil)
(setq-default auto-save-list-file-prefix nil)
#+end_src

*** OS X specific modifications

    On OS X the keyboard is a little bit fucked up when using Emacs. To
    avoid problems I shamelessly copied the =emulate-mac-keyboard.el=
    from the [[http://aquamacs.org/][Aquamacs project]], modified it a little bit and now using
    it.

    Although it might be weird because I use ZSH as my shell, I
    couldn't get =compilation-mode= to work with ZSH but with bash.

#+begin_src emacs-lisp
  (when (ck/is-osx)
    (setq shell-file-name "bash")
    (load "~/.emacs.d/emulate-mac-keyboard-mode")
    (emulate-mac-us-keyboard-mode)
    (setq mac-command-modifier 'super))
#+end_src

*** exec path initialization

#+begin_src emacs-lisp
(defun set-exec-path-from-shell-PATH ()
  (interactive)
  (let ((path-from-shell (replace-regexp-in-string "[ \t\n]*$" "" (shell-command-to-string "$SHELL --login -i -c 'echo $PATH'"))))
    (setenv "PATH" path-from-shell)
    (setq exec-path (split-string path-from-shell path-separator))))
(set-exec-path-from-shell-PATH)
#+end_src

*** Opening URLs

    Opening URLs in Emacs sucks most of the time, thus I'd like to use
    external programs (Firefox on Linux and =open= on OS X)

#+begin_src emacs-lisp
  (if (ck/is-osx)
      (setq browse-url-browser-function 'browse-url-generic
            browse-url-generic-program "open")
    (setq browse-url-browser-function 'browse-url-generic
          browse-url-generic-program "xdg-open"))
#+end_src

*** Status bar

    I like to see the current time and date in the Emacs status bar.

#+begin_src emacs-lisp
(setq display-time-24hr-format t)
(setq display-time-day-and-date t)
(setq display-time-default-load-average nil)
(display-time)
#+end_src

    Line number and column are a useful information as well.

#+begin_src emacs-lisp
(line-number-mode t)
(column-number-mode t)
#+end_src

*** Sane tab handling

    Don't get me started… ;-)

#+begin_src emacs-lisp
(setq tab-width 2)
(setq-default tab-width 2)
(setq indent-tabs-mode nil)
(setq-default indent-tabs-mode nil)
#+end_src

*** Turn on =font-lock-mode=

    We want syntax highlighting, with maximum decorations.

#+begin_src emacs-lisp
(when (fboundp 'global-font-lock-mode)
  (global-font-lock-mode t)
  (setq font-lock-maximum-decoration t))
#+end_src

*** Use UTF-8 by default

    UTF-8 is the de-facto standard, so let's use it by default.

#+begin_src emacs-lisp
; we wanna use utf8 normally
(prefer-coding-system       'utf-8)
(set-default-coding-systems 'utf-8)
#+end_src

*** Don't ring the bell

    The audio bell is highly annoying to me, let's disable it.

#+begin_src emacs-lisp
(setq ring-bell-function 'ignore)
#+end_src

*** Use =y-or-n-p= instead of =yes-or-no-p=

    I'm lazy. If I can type =y= instead of =yes=, I'll do that.  I
    also accidently hit =C-x C-c= sometimes, so let's assure that
    Emacs will ask if it is about to exit.

#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
(setq confirm-kill-emacs 'y-or-n-p)
#+end_src

*** Disabled commands

    Enable some of the disabled commands. They've been disable to
    avoid confusion for new users, but some of them are quite useful
    IMHO.

#+begin_src emacs-lisp
(put 'narrow-to-region 'disabled nil)
(put 'downcase-region 'disabled nil)
#+end_src

*** Clipboard and "yank overwrites"

I'd like to use the clipboard buffer on X11.

#+begin_src emacs-lisp
(setq x-select-enable-clipboard t)
#+end_src

I'd also like to overwrite an active region with a yank.

#+begin_src emacs-lisp
(delete-selection-mode t)
#+end_src

When we copy something from an external application and then use cut
in Emacs, the copied content is not in the kill ring. This changes
that behaviour:

#+begin_src emacs-lisp
(setq save-interprogram-paste-before-kill t)
#+end_src

*** electric indentation

I don't like to have to hit =tab= on every newline, so we enable
electric indentation.

#+begin_src emacs-lisp
(electric-indent-mode t)
#+end_src

*** Highlight current line

    Very useful to have a better overview where in the buffer the
    point is.

#+begin_src emacs-lisp
(global-hl-line-mode t)
#+end_src

*** Move by logical line, not by visual line

    By default Emacs moves lines by visual lines, but that sometimes
    sucks. Thus we use this snippet to toggle between the two
    modes. Idea by [[http://ergoemacs.org/][Xah Lee]].

#+begin_src emacs-lisp
(defun ck/toggle-line-move-visual ()
  "Toggle behavior of up/down arrow key, by visual line vs logical line."
  (interactive)
  (if line-move-visual
      (setq line-move-visual nil)
    (setq line-move-visual t)))
#+end_src

*** Safe local vars

#+begin_src emacs-lisp
(custom-set-variables
  '(safe-local-variable-values (quote ((encoding . utf-8)))))
#+end_src

*** No blinking cursor in Emacs 24.4

#+begin_src emacs-lisp
(blink-cursor-mode 0)
#+end_src

*** Make read-only regions inaccessible in minibuffer

In emacs minibuffer prompt, when you press the left arrow key, the
cursor will move back all the way over the prompt text. This is
annoying because user often will hold down 【Alt+b】 to move back by
word to edit, and when user starts to type something, emacs will say
„This is read-only.“ Then you have to manually move cursor out of the
prompt

#+begin_src emacs-lisp
(setq minibuffer-prompt-properties (quote (read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt)))
#+end_src


** Theming and fonts

*** Fonts

    I use [[https://github.com/adobe-fonts/source-code-pro][Source Code Pro]]. Period.

#+begin_src emacs-lisp
(if (ck/is-osx)
    (progn
      (set-default-font "Source Code Pro-12")
      (set-fontset-font "fontset-default" nil
                        (font-spec :size 12 :name "Source Code Pro"))
      (set-face-attribute 'default nil
                          :family "Source Code Pro"
                          :height 120
                          :weight 'normal
                          :width 'normal)
      (push '(font . "Source Code Pro-12") default-frame-alist))
  (progn
    (set-default-font "Source Code Pro-09")
    (set-fontset-font "fontset-default" nil
                      (font-spec :size 9 :name "Source Code Pro"))
    (set-face-attribute 'default nil
                        :family "Source Code Pro"
                        :height 90
                        :weight 'normal
                        :width 'normal)
    (push '(font . "Source Code Pro-09") default-frame-alist)))
#+end_src

*** Theme

    I'm using the Tomorrow theme in the eighties variant.

#+begin_src emacs-lisp
    (custom-set-variables
     ;'(custom-enabled-themes (quote (sanityinc-tomorrow-eighties)))
     '(custom-enabled-themes (quote (sanityinc-tomorrow-eighties sanityinc-tomorrow-night)))
     '(custom-safe-themes    (quote ("628278136f88aa1a151bb2d6c8a86bf2b7631fbea5f0f76cba2a0079cd910f7d"
                                     "06f0b439b62164c6f8f84fdda32b62fb50b6d00e8b01c2208e55543a6337433a"
                                     "3c83b3676d796422704082049fc38b6966bcad960f896669dfc21a7a37a748fa"
                                     default))))

    (load-theme 'sanityinc-tomorrow-eighties t)
    (setq current-theme 'sanityinc-tomorrow-eighties)

    (defun ck/switch-theme ()
      (interactive)
      (if (eq current-theme 'sanityinc-tomorrow-eighties)
          (progn
            (load-theme 'sanityinc-tomorrow-day t)
            (setq current-theme 'sanityinc-tomorrow-day))
        (progn
          (load-theme 'sanityinc-tomorrow-eighties t)
          (setq current-theme 'sanityinc-tomorrow-eighties))))

    (define-key ck/keys-minor-mode-map (kbd "C-c c c") 'ck/switch-theme)
#+end_src

** Helpers

*** Open a file as root

#+begin_src emacs-lisp
(defun ck/find-file-as-root ()
  "Like `ido-find-file, but automatically edit the file with
root-privileges (using tramp/sudo), if the file is not writable by
user."
  (interactive)
  (let ((file (helm-read-file-name "Edit as root: ")))
    (unless (file-writable-p file)
      (setq file (concat "/sudo:root@localhost:" file)))
    (find-file file)))

(global-set-key (kbd "C-x F") 'ck/find-file-as-root)
#+end_src

*** Smarter beginning of line (like Sublime Text)

#+begin_src emacs-lisp
(defun smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

Move point to the first non-whitespace character on this line.
If point is already there, move to the beginning of the line.
Effectively toggle between the first non-whitespace character and
the beginning of the line.

If ARG is not nil or 1, move forward ARG - 1 lines first.  If
point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

(global-set-key [home] 'smarter-move-beginning-of-line)
(global-set-key [s-left] 'smarter-move-beginning-of-line)
#+end_src

*** Go to matching paren (or the equivalent in ruby)

#+begin_src emacs-lisp
(defun goto-match-paren (arg)
  "Go to the matching  if on (){}[], similar to vi style of % "
  (interactive "p")
  ;; first, check for "outside of bracket" positions expected by forward-sexp, etc
  (cond ((looking-at "[\[\(\{]") (forward-sexp))
        ((looking-back "[\]\)\}]" 1) (backward-sexp))
        ;; now, try to succeed from inside of a bracket
        ((looking-at "[\]\)\}]") (forward-char) (backward-sexp))
        ((looking-back "[\[\(\{]" 1) (backward-char) (forward-sexp))
        (t nil)))

(defun goto-matching-ruby-block (arg)
  (cond
   ((equal (current-word) "end")
    (ruby-beginning-of-block))

   ((string-match (current-word) "\\(for\\|while\\|until\\|if\\|class\\|module\\|case\\|unless\\|def\\|begin\\|do\\)")
    (ruby-end-of-block))))

(defun dispatch-goto-matching (arg)
  (interactive "p")

  (if (or
       (looking-at "[\[\(\{]")
       (looking-at "[\]\)\}]")
       (looking-back "[\[\(\{]" 1)
       (looking-back "[\]\)\}]" 1))
      (goto-match-paren arg)

    (when (eq major-mode 'ruby-mode)
      (goto-matching-ruby-block arg))))

(global-set-key "\M--" 'dispatch-goto-matching)
#+end_src


*** RGB notation to hex

    As a web developer I often get colors as RGB values. In CSS they
    have to be notated in hex; to shorten that I wrote a little
    =defun=.

#+begin_src emacs-lisp
(defun region-to-hexcol ()
  (interactive)
  (let
      ((start (region-beginning))
       (end (region-end))
       (text))

    (setq text (buffer-substring-no-properties start end))

    (when (string-match "^[[:digit:]]+$" text)
      (setq text (format "%02x" (string-to-number text)))
      (delete-region start end)
      (insert text))))

(defun rgb-to-hex ()
  (interactive)

  (let
      ((start (region-beginning))
       (end (region-end)))

    (goto-char start)
    (set-mark start)
    (skip-chars-forward "0-9")
    (region-to-hexcol)

    (skip-chars-forward ", ")
    (set-mark (point))
    (skip-chars-forward "0-9")
    (region-to-hexcol)

    (skip-chars-forward ", ")
    (set-mark (point))
    (skip-chars-forward "0-9")
    (region-to-hexcol)

    (setq end (point))
    (goto-char start)

    (save-restriction
      (narrow-to-region start end)
      (while (re-search-forward "[, ]" nil t) (replace-match "" nil t)))))
#+end_src

*** Kill all buffers

#+begin_src emacs-lisp
(defun kill-all-buffers ()
  (interactive)
  (mapcar 'kill-buffer (buffer-list))
  (delete-other-windows))

(global-set-key (kbd "C-x K") 'kill-all-buffers)
#+end_src

** Tramp

   Tramp has problems with the ZSH, so ensure we use Bash.

#+begin_src emacs-lisp
  (eval-after-load 'tramp '(setenv "SHELL" "/bin/bash"))
  (use-package tramp
    :init (setq tramp-use-ssh-controlmaster-options nil
                tramp-ssh-controlmaster-options nil))
#+end_src

** SSL configuration

   There are some problems with the default SSL configuration in
   Emacs. I found this in the interwebs and it works.

#+begin_src emacs-lisp
(setq ssl-program-name "openssl s_client -ssl2 -connect %s:%p")
(setq-default ssl-program-name "openssl s_client -ssl2 -connect %s:%p")
#+end_src

** Project management

   I'm using [[https://github.com/bbatsov/projectile][projectile]] for project management.

#+begin_src emacs-lisp
  (use-package projectile
    :init (progn
            (projectile-global-mode)

            (setq projectile-indexing-method 'find
                  projectile-enable-caching t)

            (defun build-ctags ()
              (interactive)
              (message "building project tags")
              (let ((root (projectile-project-root))
                    (ctags (if (ck/is-osx)
                               "/usr/local/bin/ctags"
                             "/usr/bin/ctags")))
                (if (string-match "/ios/" root)
                    (shell-command (concat "find " root " -name '*.[hm]' | xargs /usr/local/bin/etags"))
                  (shell-command (concat ctags " -e -R --extra=+fq --exclude=db --exclude=test --exclude=.git --exclude=public -f " root "/TAGS " root))))
              (visit-project-tags)
              (message "tags built successfully"))

            (defun visit-project-tags ()
              (interactive)
              (let ((tags-file (concat (projectile-project-root) "/TAGS")))
                (visit-tags-table tags-file)
                (message (concat "Loaded " tags-file))))))
#+end_src

** Keyboard shortcuts

I've got some global keyboard shortcuts, inherited from the 90s. I got
so much used to them that I can't get rid of them.

#+begin_src emacs-lisp
(global-set-key [end] 'end-of-line)
(global-set-key [s-right] 'end-of-line)

(global-set-key [C-home] 'beginning-of-buffer)
(global-set-key [s-up] 'beginning-of-buffer)

(global-set-key [C-end] 'end-of-buffer)
(global-set-key [s-down] 'end-of-buffer)

(define-key ck/keys-minor-mode-map (kbd "M-<") 'pop-to-mark-command)
(define-key ck/keys-minor-mode-map (kbd "C--") 'dabbrev-expand)
(define-key ck/keys-minor-mode-map (kbd "s-.") 'find-tag)
(define-key ck/keys-minor-mode-map (kbd "s-}") 'pop-tag-mark)

(when (not (ck/is-osx))
  (define-key ck/keys-minor-mode-map (kbd "s-u") 'revert-buffer))

(define-minor-mode ck/keys-minor-mode
  "A minor mode so that my key settings override annoying major modes."
  t " ck/keys" 'ck/keys-minor-mode-map)

(ck/keys-minor-mode 1)

(defun ck/minibuffer-setup-hook ()
  (ck/keys-minor-mode 0))

(add-hook 'minibuffer-setup-hook 'ck/minibuffer-setup-hook)
(define-key minibuffer-local-map (kbd "C--") 'dabbrev-expand)
#+end_src

*** Hydra

Hydra is a nice, relatively new package which basically gives you the
ability to repeat a command bound to a keystroke by hitting the last
key again. I instantly fell in love with it.

#+begin_src emacs-lisp
  (use-package hydra
    :init (progn
            ;; testing hydra; keybindings for testing from within emacs
            (define-key ck/keys-minor-mode-map "\C-cct"
              (defhydra tests (:color blue)
                "testing"
                ("p" run-test-at-point "run test at point")
                ("f" run-test-file "run test file")
                ("s" run-test-suite "run test suite")))))
#+end_src

** Shortcuts for opening often used files

   Some of my more often used files (like my =org-mode= inbox file)
   get it's own shortcut:

#+begin_src emacs-lisp
  (define-key ck/keys-minor-mode-map "\C-ccf"
    (defhydra often-used-files (:color blue)
      "often used files"
      ("p" (find-file "~/Documents/org/passwords.org.gpg") "open passwords file")
      ("i" (find-file "~/Documents/org/inbox.org") "Open org-mode inbox file")
      ("t" (find-file "~/Documents/org/work/termitel.org") "Open termitel org-mode file")))

#+end_src

** Parens

[[https://github.com/Fuco1/smartparens][Smartparens]] really rocks, it is one of my most-used Emacs customizations.

#+begin_src emacs-lisp
  (use-package smartparens
    :init
    (require 'smartparens-config)
    (require 'smartparens-ruby)

    (smartparens-global-mode)
    (show-smartparens-global-mode t))
#+end_src

** buffer names

In Emacs each buffer has a unique name. For file buffers the name is
derived from the file name, so for example a buffer associated with
the file =README= is named =README=. This is fine as long as you don’t
open files with the same name. To ensure the uniqueness of the buffer
name Emacs will append a number to the buffer name, for example
=README<1>=. I configured it to append the directory parts to the
buffer name instead of prepending it, in this way the name is still
the most prominent info:

#+begin_src emacs-lisp
(use-package uniquify
  :init
  (setq uniquify-buffer-name-style 'post-forward uniquify-separator ":"))
#+end_src

** narrow-or-widen-dwim

=narrow-or-widen-dwim= is a nice piece of code from [[http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html][Endless
Parentheses]] for an intuitive narrow/widen behaviour.

#+begin_src emacs-lisp
  (defun narrow-or-widen-dwim (p)
    "Widen if buffer is narrowed, narrow-dwim otherwise.
  Dwim means: region, org-src-block, org-subtree, or defun,
  whichever applies first. Narrowing to org-src-block actually
  calls `org-edit-src-code'.

  With prefix P, don't widen, just narrow even if buffer is
  already narrowed."
    (interactive "P")
    (declare (interactive-only))
    (cond ((and (buffer-narrowed-p) (not p)) (widen))
          ((region-active-p)
           (narrow-to-region (region-beginning) (region-end)))
          ((derived-mode-p 'org-mode)
           ;; `org-edit-src-code' is not a real narrowing
           ;; command. Remove this first conditional if you
           ;; don't want it.
           (cond ((ignore-errors (org-edit-src-code))
                  (delete-other-windows))
                 ((ignore-errors (org-narrow-to-block) t))
                 (t (org-narrow-to-subtree))))
          ((derived-mode-p 'latex-mode)
           (LaTeX-narrow-to-environment))
          (t (narrow-to-defun))))

  (define-key ck/keys-minor-mode-map (kbd "C-x n") 'narrow-or-widen-dwim)
#+end_src

** Avy

Avy is a mode for easy movements to specific positions in the file.

#+begin_src emacs-lisp
  (use-package avy
    :commands (avy-goto-word-1 avy-goto-line)
    :init (progn
            (define-key ck/keys-minor-mode-map (kbd "C-c SPC") 'avy-goto-word-1)
            (define-key ck/keys-minor-mode-map (kbd "M-g g") 'avy-goto-line)
            (define-key ck/keys-minor-mode-map (kbd "M-g M-g") 'avy-goto-line)))
#+end_src

*** ace-window

[[https://github.com/abo-abo/ace-window][ace-window]] is a mode based on =ace-jump-mode= which makes buffer
switching similiar to it. Very nice!

#+begin_src emacs-lisp
  (use-package ace-window
    :init
    (define-key ck/keys-minor-mode-map (kbd "C-x o") 'ace-window))
#+end_src

** org-mode

   [[http://orgmode.org/][Organize your live in plain text!]]

#+begin_src emacs-lisp
  (require 'org-loaddefs)
  (require 'org-agenda)
  (require 'org-protocol)

  ;; Explicitly load required exporters
  (require 'ox-html)
  (require 'ox-latex)
  (require 'ox-ascii)

  (add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\)$" . org-mode))

  (setq org-directory "~/Documents/org")
  (setq org-mobile-directory "/scp:ckruse@jugulator.defunced.de:/var/www/cloud.defunct.ch/htdocs/org")
  (setq org-agenda-files (quote ("~/Documents/org/" "~/Documents/org/priv"
                                 "~/Documents/org/work" "~/Documents/org/foss")))
  (setq org-mobile-inbox-for-pull "~/Documents/org/inbox.org")
  (setq org-default-notes-file (concat org-directory "/inbox.org"))

  (add-hook 'org-mode-hook 'turn-on-font-lock)

  (setq org-todo-keywords
        (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)"
                          "PHONE" "MEETING"))))

  (setq org-todo-keyword-faces
        (quote (("TODO" :foreground "red" :weight bold)
                ("NEXT" :foreground "blue" :weight bold)
                ("DONE" :foreground "forest green" :weight bold)
                ("WAITING" :foreground "orange" :weight bold)
                ("HOLD" :foreground "magenta" :weight bold)
                ("CANCELLED" :foreground "forest green" :weight bold)
                ("MEETING" :foreground "forest green" :weight bold)
                ("PHONE" :foreground "forest green" :weight bold))))

  ;; use C-c C-t <KEY> for fast selection of todo state
  (setq org-use-fast-todo-selection t)

  (setq org-treat-S-cursor-todo-selection-as-state-change nil)


  (setq org-todo-state-tags-triggers
        (quote (("CANCELLED" ("CANCELLED" . t))
                ("WAITING" ("WAITING" . t))
                ("HOLD" ("WAITING") ("HOLD" . t))
                (done ("WAITING") ("HOLD"))
                ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
                ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
                ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))

  (setq org-capture-templates
        (quote (("t" "todo" entry (file+headline "~/Documents/org/inbox.org" "Inbox")
                 "* TODO %?\n%U\n%a\n" :clock-in t :clock-resume t)
                ("n" "note" entry (file+headline "~/Documents/org/notes.org" "Notizen")
                 "* %?\n%U\n" :clock-in t :clock-resume t)
                ("w" "blog entry" entry (file+headline "~/Documents/org/inbox.org" "Inbox")
                 "* TODO %? :blog:\n%U\n" :clock-in t :clock-resume t)
                ("j" "Journal" entry (file+datetree "~/Documents/org/priv/diary.org")
                 "* %?\n%U\n" :clock-in t :clock-resume t)
                ("m" "Meeting" entry (file+headline "~/Documents/org/inbox.org" "Inbox")
                 "* MEETING with %? :MEETING:\n%U" :clock-in t :clock-resume t)
                ("c" "Phone call" entry (file+headline "~/Documents/org/inbox.org" "Inbox")
                 "* PHONE %? :PHONE:\n%U" :clock-in t :clock-resume t)
                ("b" "Bookmark" entry (file+headline "~/Documents/org/bookmarks.org" "Inbox")
                 "* %?")
                ("p" "password" entry (file "~/Documents/org/passwords.gpg")
                 "* %^{Title}\n  %^{URL}p %^{USERNAME}p %^{PASSWORD}p"))))


  ; Set default column view headings: Task Effort Clock_Summary
  (setq org-columns-default-format "%80ITEM(Task) %10Effort(Effort){:} %10CLOCKSUM")
  ; global Effort estimate values
  ; global STYLE property values for completion
  (setq org-global-properties (quote (("Effort_ALL" . "0:15 0:30 0:45 1:00 2:00 3:00 4:00 5:00 6:00 0:00")
                                      ("STYLE_ALL" . "habit"))))

  ;; Remove empty LOGBOOK drawers on clock out
  (defun bh/remove-empty-drawer-on-clock-out ()
    (interactive)
    (save-excursion
      (beginning-of-line 0)
      (org-remove-empty-drawer-at (point))))

  (add-hook 'org-clock-out-hook 'bh/remove-empty-drawer-on-clock-out 'append)


  (define-key ck/keys-minor-mode-map "\C-cco"
    (defhydra org (:color blue)
      "org actions"
      ("a" org-agenda "Agenda")
      ("l" org-store-link "Store link")
      ("b" org-iswitchb "Org switch buffer")
      ("A" org-archive-subtree "Archive subtree" :color red)

      ("c" org-capture "Capture")
      ("i" bh/punch-in "Punch in")
      ("o" bh/punch-out "Punch out")

      ("g" org-clock-goto "Goto clock")
      ("I" org-clock-in "Clock in")
      ("p" org-publish-all "Publish")))



  ;;;;;;;;;;;;;;;;;
  ;; clock setup ;;
  ;;;;;;;;;;;;;;;;;

  ;;
  ;; Resume clocking task when emacs is restarted
  (org-clock-persistence-insinuate)
  ;;
  ;; Show lot of clocking history so it's easy to pick items off the C-F11 list
  (setq org-clock-history-length 23)
  ;; Resume clocking task on clock-in if the clock is open
  (setq org-clock-in-resume t)
  ;; Change tasks to NEXT when clocking in
  (setq org-clock-in-switch-to-state 'bh/clock-in-to-next)
  ;; Separate drawers for clocking and logs
  (setq org-drawers (quote ("PROPERTIES" "LOGBOOK")))
  ;; Save clock data and state changes and notes in the LOGBOOK drawer
  (setq org-clock-into-drawer t)
  ;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks with 0:00 duration
  (setq org-clock-out-remove-zero-time-clocks t)
  ;; Clock out when moving task to a done state
  (setq org-clock-out-when-done t)
  ;; Save the running clock and all clock history when exiting Emacs, load it on startup
  (setq org-clock-persist t)
  ;; Do not prompt to resume an active clock
  (setq org-clock-persist-query-resume nil)
  ;; Enable auto clock resolution for finding open clocks
  (setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
  ;; Include current clocking task in clock reports
  (setq org-clock-report-include-clocking-task t)

  (setq bh/keep-clock-running nil)

  (defvar bh/organization-task-id "BADA377F-DABB-4C51-BC7B-99C574DCE45D")

  (add-hook 'org-clock-out-hook 'bh/clock-out-maybe 'append)


  ;;;;;;;;;;;;;;;
  ;; exporting ;;
  ;;;;;;;;;;;;;;;

  (setq org-alphabetical-lists t)

  (setq org-html-inline-images t)
  ; Export with LaTeX fragments
  (setq org-export-with-LaTeX-fragments t)
  ; Increase default number of headings to export
  (setq org-export-headline-levels 6)
  ; disable sup/sub scripts
  (setq org-use-sub-superscripts nil)

  (setq org-html-doctype "html5")
  (setq org-html-head-include-default-style nil)

  ;;(setq debug-on-error t)
  (setq org-publish-project-alist
        ;
        ; Termitel Todo list
        ; org-mode-doc-org this document
        ; org-mode-doc-extra are images and css files that need to be included
        ; org-mode-doc is the top-level project that gets published
        ; This uses the same target directory as the 'doc' project
        (quote (("org"
                 :base-directory "~/Documents/org/"
                 :publishing-directory "/ssh:ckruse@jugulator.defunced.de:/var/www/cloud.defunct.ch/htdocs/todo/"
                 :recursive t
                 :section-numbers nil
                 :table-of-contents nil
                 :base-extension "org"
                 :publishing-function org-html-publish-to-html
                 :html-head "<link rel=\"stylesheet\" href=\"https://cloud.defunct.ch/todo/org.css\" type=\"text/css\">"
                 :plain-source t
                 :htmlized-source t
                 :style-include-default nil
                 :auto-sitemap t
                 :sitemap-filename "index.html"
                 :sitemap-title "CKs Org"
                 :sitemap-style "tree"
                 :author-info t
                 :creator-info t
                 :exclude "passwords"))))



  ;;;;;;;;;;;;;;;;;;
  ;; refile setup ;;
  ;;;;;;;;;;;;;;;;;;

  (setq org-refile-targets (quote ((nil :maxlevel . 9)
                                   (org-agenda-files :maxlevel . 9))))
  (setq org-refile-use-outline-path t)
  (setq org-outline-path-complete-in-steps nil)
  (setq org-refile-allow-creating-parent-nodes (quote confirm))
  (setq org-completion-use-ido t)

  (defun bh/is-project-p ()
    "Any task with a todo keyword subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task has-subtask))))

  (defun bh/is-project-subtree-p ()
    "Any task with a todo keyword that is in a project subtree.
  Callers of this function already widen the buffer view."
    (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                (point))))
      (save-excursion
        (bh/find-project-task)
        (if (equal (point) task)
            nil
          t))))

  (defun bh/is-task-p ()
    "Any task with a todo keyword and no subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task (not has-subtask)))))

  (defun bh/is-subproject-p ()
    "Any task which is a subtask of another project"
    (let ((is-subproject)
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (while (and (not is-subproject) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq is-subproject t))))
      (and is-a-task is-subproject)))

  (defun bh/list-sublevels-for-projects-indented ()
    "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
    This is normally used by skipping functions where this variable is already local to the agenda."
    (if (marker-buffer org-agenda-restrict-begin)
        (setq org-tags-match-list-sublevels 'indented)
      (setq org-tags-match-list-sublevels nil))
    nil)

  (defun bh/list-sublevels-for-projects ()
    "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
    This is normally used by skipping functions where this variable is already local to the agenda."
    (if (marker-buffer org-agenda-restrict-begin)
        (setq org-tags-match-list-sublevels t)
      (setq org-tags-match-list-sublevels nil))
    nil)

  (defvar bh/hide-scheduled-and-waiting-next-tasks t)

  (defun bh/toggle-next-task-display ()
    (interactive)
    (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
    (when  (equal major-mode 'org-agenda-mode)
      (org-agenda-redo))
    (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

  (defun bh/skip-stuck-projects ()
    "Skip trees that are not stuck projects"
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (if (bh/is-project-p)
            (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                   (has-next ))
              (save-excursion
                (forward-line 1)
                (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                  (unless (member "WAITING" (org-get-tags-at))
                    (setq has-next t))))
              (if has-next
                  nil
                next-headline)) ; a stuck project, has subtasks but no next task
          nil))))

  (defun bh/skip-non-stuck-projects ()
    "Skip trees that are not stuck projects"
    ;; (bh/list-sublevels-for-projects-indented)
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (if (bh/is-project-p)
            (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                   (has-next ))
              (save-excursion
                (forward-line 1)
                (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                  (unless (member "WAITING" (org-get-tags-at))
                    (setq has-next t))))
              (if has-next
                  next-headline
                nil)) ; a stuck project, has subtasks but no next task
          next-headline))))

  (defun bh/skip-non-projects ()
    "Skip trees that are not projects"
    ;; (bh/list-sublevels-for-projects-indented)
    (if (save-excursion (bh/skip-non-stuck-projects))
        (save-restriction
          (widen)
          (let ((subtree-end (save-excursion (org-end-of-subtree t))))
            (cond
             ((bh/is-project-p)
              nil)
             ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
              nil)
             (t
              subtree-end))))
      (save-excursion (org-end-of-subtree t))))

  (defun bh/skip-project-trees-and-habits ()
    "Skip trees that are projects"
    (save-restriction
      (widen)
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ((org-is-habit-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-projects-and-habits-and-single-tasks ()
    "Skip trees that are projects, tasks that are habits, single non-project tasks"
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((org-is-habit-p)
          next-headline)
         ((and bh/hide-scheduled-and-waiting-next-tasks
               (member "WAITING" (org-get-tags-at)))
          next-headline)
         ((bh/is-project-p)
          next-headline)
         ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
          next-headline)
         (t
          nil)))))

  (defun bh/skip-project-tasks-maybe ()
    "Show tasks related to the current restriction.
  When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
  When not restricted, skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (next-headline (save-excursion (or (outline-next-heading) (point-max))))
             (limit-to-project (marker-buffer org-agenda-restrict-begin)))
        (cond
         ((bh/is-project-p)
          next-headline)
         ((org-is-habit-p)
          subtree-end)
         ((and (not limit-to-project)
               (bh/is-project-subtree-p))
          subtree-end)
         ((and limit-to-project
               (bh/is-project-subtree-p)
               (member (org-get-todo-state) (list "NEXT")))
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-project-tasks ()
    "Show non-project tasks.
  Skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ((org-is-habit-p)
          subtree-end)
         ((bh/is-project-subtree-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-non-project-tasks ()
    "Show project tasks.
  Skip project and sub-project tasks, habits, and loose non-project tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((bh/is-project-p)
          next-headline)
         ((org-is-habit-p)
          subtree-end)
         ((and (bh/is-project-subtree-p)
               (member (org-get-todo-state) (list "NEXT")))
          subtree-end)
         ((not (bh/is-project-subtree-p))
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-projects-and-habits ()
    "Skip trees that are projects and tasks that are habits"
    (save-restriction
      (widen)
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ((org-is-habit-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-non-subprojects ()
    "Skip trees that are not projects"
    (let ((next-headline (save-excursion (outline-next-heading))))
      (if (bh/is-subproject-p)
          nil
        next-headline)))

  (defun bh/clock-in-to-next (kw)
    "Switch a task from TODO to NEXT when clocking in.
  Skips capture tasks, projects, and subprojects.
  Switch projects and subprojects from NEXT back to TODO"
    (when (not (and (boundp 'org-capture-mode) org-capture-mode))
      (cond
       ((and (member (org-get-todo-state) (list "TODO"))
             (bh/is-task-p))
        "NEXT")
       ((and (member (org-get-todo-state) (list "NEXT"))
             (bh/is-project-p))
        "TODO"))))

  (defun bh/find-project-task ()
    "Move point to the parent (project) task if any"
    (save-restriction
      (widen)
      (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
        (while (org-up-heading-safe)
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (goto-char parent-task)
        parent-task)))

  (defun bh/punch-in (arg)
    "Start continuous clocking and set the default task to the
  selected task.  If no task is selected set the Organization task
  as the default task."
    (interactive "p")
    (setq bh/keep-clock-running t)
    (if (equal major-mode 'org-agenda-mode)
        ;;
        ;; We're in the agenda
        ;;
        (let* ((marker (org-get-at-bol 'org-hd-marker))
               (tags (org-with-point-at marker (org-get-tags-at))))
          (if (and (eq arg 4) tags)
              (org-agenda-clock-in '(16))
            (bh/clock-in-organization-task-as-default)))
      ;;
      ;; We are not in the agenda
      ;;
      (save-restriction
        (widen)
        ; Find the tags on the current task
        (if (and (equal major-mode 'org-mode) (not (org-before-first-heading-p)) (eq arg 4))
            (org-clock-in '(16))
          (bh/clock-in-organization-task-as-default)))))

  (defun bh/punch-out ()
    (interactive)
    (setq bh/keep-clock-running nil)
    (when (org-clock-is-active)
      (org-clock-out))
    (org-agenda-remove-restriction-lock))

  (defun bh/clock-in-default-task ()
    (save-excursion
      (org-with-point-at org-clock-default-task
        (org-clock-in))))

  (defun bh/clock-in-parent-task ()
    "Move point to the parent (project) task if any and clock in"
    (let ((parent-task))
      (save-excursion
        (save-restriction
          (widen)
          (while (and (not parent-task) (org-up-heading-safe))
            (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
              (setq parent-task (point))))
          (if parent-task
              (org-with-point-at parent-task
                (org-clock-in))
            (when bh/keep-clock-running
              (bh/clock-in-default-task)))))))

  (defun bh/clock-in-organization-task-as-default ()
    (interactive)
    (org-with-point-at (org-id-find bh/organization-task-id 'marker)
      (org-clock-in '(16))))

  (defun bh/clock-out-maybe ()
    (when (and bh/keep-clock-running
               (not org-clock-clocking-in)
               (marker-buffer org-clock-default-task)
               (not org-clock-resolving-clocks-due-to-idleness))
      (bh/clock-in-parent-task)))

#+end_src

** yasnippet

[[https://github.com/capitaomorte/yasnippet][YASnippet]] is a snippet system for Emacs, similiar to TextMate's tab
triggered snippets.

#+begin_src emacs-lisp
(use-package yasnippet
  :init
  (yas-global-mode 1))
#+end_src

** web-mode

As a web developer [[http://web-mode.org/][web-mode]] is a must-have. It enables
pseudo-multi-modes (for web templates, where you often have mixed
contents like CSS, JS and HTML in one file).

#+begin_src emacs-lisp
(use-package web-mode
  :commands web-mode

  :init
  (progn
    (add-to-list 'auto-mode-alist '("\\.html\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.jsp\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.html\\.eex\\'" . web-mode)))

  :config
  (progn
    (defun ck/web-mode-hook ()
      "Hooks for Web mode."
      (setq web-mode-markup-indent-offset 2)
      (setq web-mode-css-indent-offset 2)
      (setq web-mode-code-indent-offset 2))
    (add-hook 'web-mode-hook 'ck/web-mode-hook)
    (custom-set-variables
     '(web-mode-disable-auto-pairing t)
     '(web-mode-enable-auto-pairing nil))))
#+end_src

** autocomplete

Autocomplete provides a nice autocompletion feature for Emacs,
similiar to the autocompletion provided by XCode.

#+begin_src emacs-lisp
  (use-package auto-complete-config
    :init
    (ac-config-default)

    (setq web-mode-ac-sources-alist
          '(("erb" . (ac-source-yasnippet
                      ac-source-abbrev
                      ac-source-gtags
                      ac-source-semantic
                      ac-source-dictionary
                      ac-source-words-in-same-mode-buffers
                      ac-source-words-in-buffer
                      ac-source-files-in-current-dir))
            ("php" . (ac-source-yasnippet ac-source-php-auto-yasnippets
                      ac-source-yasnippet
                      ac-source-abbrev
                      ac-source-gtags
                      ac-source-semantic
                      ac-source-dictionary
                      ac-source-words-in-same-mode-buffers
                      ac-source-words-in-buffer
                      ac-source-files-in-current-dir))
            ("css" . (ac-source-css-property))
            ("html" . (ac-source-words-in-buffer ac-source-abbrev))))

    (add-to-list 'ac-modes 'objc-mode)
    (add-to-list 'ac-modes 'web-mode)
    (add-to-list 'ac-modes 'sql-mode)
    (add-to-list 'ac-modes 'c-mode)
    (add-to-list 'ac-modes 'swift-mode)

    (add-hook 'web-mode-before-auto-complete-hooks
              '(lambda ()
                 (let ((web-mode-cur-language
                        (web-mode-language-at-pos)))
                   (if (string= web-mode-cur-language "php")
                       (yas-activate-extra-mode 'php-mode)
                     (yas-deactivate-extra-mode 'php-mode))

                   (if (string= web-mode-cur-language "erb")
                       (yas-activate-extra-mode 'ruby-mode)
                     (yas-deactivate-extra-mode 'ruby-mode))))))
#+end_src

** key-chord

#+begin_src emacs-lisp
  (use-package key-chord
   :init
   (key-chord-mode 1)
   (key-chord-define-global "uu" 'undo)
   (key-chord-define-global "yy" 'ace-window)
   (key-chord-define-global "jl" 'ace-jump-word-mode)
   (key-chord-define-global "jl" 'ace-jump-line-mode))

#+end_src

** PostgreSQL

PostgreSQL has its own, very specific indentation settings. We have to
respect that.

#+begin_src emacs-lisp
(c-add-style "postgresql"
             '("bsd"
               (c-auto-align-backslashes . nil)
               (c-basic-offset . 4)
               (c-offsets-alist . ((case-label . +)
                                   (label . -)
                                   (statement-case-open . +)))
               (fill-column . 78)
               (indent-tabs-mode . t)
               (tab-width . 4)))

;; perl files

(defun pgsql-perl-style ()
  "Perl style adjusted for PostgreSQL project"
  (interactive)
  (setq perl-brace-imaginary-offset 0)
  (setq perl-brace-offset 0)
  (setq perl-continued-brace-offset 4)
  (setq perl-continued-statement-offset 4)
  (setq perl-indent-level 4)
  (setq perl-label-offset -2)
  (setq tab-width 4))

(add-hook 'perl-mode-hook
          (defun postgresql-perl-mode-hook ()
            (when (string-match "/postgres\\(ql\\)?/" buffer-file-name)
              (pgsql-perl-style))))

;; doc files

(add-hook 'sgml-mode-hook
          (defun postgresql-sgml-mode-hook ()
            (when (and buffer-file-name (string-match "/postgres\\(ql\\)?/" buffer-file-name))
              (setq fill-column 78)
              (setq indent-tabs-mode nil)
              (setq sgml-basic-offset 1))))


;;; Makefiles

;; use GNU make mode instead of plain make mode
(add-to-list 'auto-mode-alist '("/postgres\\(ql\\)?/.*Makefile.*" . makefile-gmake-mode))
(add-to-list 'auto-mode-alist '("/postgres\\(ql\\)?/.*\\.mk\\'" . makefile-gmake-mode))
#+end_src

** C/C++ modifications

Just indentation in a sane way.

#+begin_src emacs-lisp
(defun ck-init-c ()
  (if (string-match "/postgres/" buffer-file-name)
      (progn
        (c-set-style "postgresql")
        (setq c-basic-offset 2)
        (setq-default c-basic-offset 2))

    (progn
      (c-set-style "bsd")
      (setq c-basic-offset 2)
      (c-set-offset 'arglist-cont 0)
      (c-set-offset 'arglist-intro 2)
      (c-set-offset 'case-label 2)
      (c-set-offset 'arglist-close 0))))

(add-hook 'c-mode-hook 'ck-init-c)
(add-hook 'c++-mode-hook 'ck-init-c)
#+end_src

** CMake support

We want to be able to edit CMake files in a sane way.

#+begin_src emacs-lisp
  (use-package cmake-mode
    :commands cmake-mode
    :init (progn
            (add-to-list 'auto-mode-alist '(".cmake" . cmake-mode))
            (add-to-list 'auto-mode-alist '("CMakeLists.txt" . cmake-mode))))
#+end_src

** Elang support

#+begin_src emacs-lisp
  (defun erl-get-lib-path (path)
    (format "%s/%s/emacs" path (car (directory-files path nil "^tools"))))

  (cond
   ((file-exists-p "/usr/local/lib/erlang")
    (setq load-path (cons (erl-get-lib-path "/usr/local/lib/erlang/lib") load-path))
    (setq erlang-root-dir "/usr/local/lib/erlang")
    (require 'erlang-start))

   ((file-exists-p "/usr/lib/erlang")
    (setq load-path (cons (erl-get-lib-path "/usr/lib/erlang/lib") load-path))
    (setq erlang-root-dir "/usr/lib/erlang")
    (require 'erlang-start)))

#+end_src

** expand-region

[[https://github.com/magnars/expand-region.el][expand-region]] is an Emacs extension to increase selected region by semantic units.

#+begin_src emacs-lisp
  (use-package expand-region
    :commands expand-region
    :init (progn
            (define-key ck/keys-minor-mode-map "\C-cce"
              (defhydra expand-region (:color red)
                "expand region as a hydra"
                ("e" er/expand-region "Expand region")))))
#+end_src

** flycheck

   [[https://github.com/flycheck/flycheck][Flycheck]] is a nice mode for on-the-fly syntax checking.

#+begin_src emacs-lisp
(add-hook 'after-init-hook #'global-flycheck-mode)

(setq flycheck-check-syntax-automatically '(mode-enabled new-line save))
(setq flycheck-jshintrc "~/.emacs.d/jshint.json")
(setq flycheck-disabled-checkers '(emacs-lisp emacs-lisp-checkdoc))
(setq-default flycheck-disabled-checkers '(emacs-lisp emacs-lisp-checkdoc))
#+end_src

** flyspell

[[http://www.emacswiki.org/emacs/FlySpell][Fly Spell]] enables on-the-fly spell checking in Emacs.

#+begin_src emacs-lisp
(defun fd-switch-dictionary()
  (interactive)
  (let* ((dic ispell-current-dictionary)
         (change (if (string= dic "deutsch") "en" "deutsch")))
    (ispell-change-dictionary change)
    (message "Dictionary switched from %s to %s" dic change)))

(add-hook 'mail-mode-hook 'flyspell-mode)
(add-hook 'markdown-mode-hook 'flyspell-mode)
(add-hook 'rst-mode-hook 'flyspell-mode)

(setq ispell-program-name "aspell")
#+end_src

** ibuffer

   [[http://www.emacswiki.org/emacs/IbufferMode][IBuffer]] is an advanced replacement for BufferMenu. Very neat for
   switching buffers and such.

#+begin_src emacs-lisp
  (use-package ibuffer
    :commands ibuffer
    :init (progn
            (define-key ck/keys-minor-mode-map (kbd "C-x C-b") 'ibuffer)

            (defun ck/define-projectile-filter-groups ()
              (when (boundp 'projectile-known-projects)
                (setq my/project-filter-groups
                      (mapcar
                       (lambda (it)
                         (let ((name (file-name-nondirectory (directory-file-name it))))
                           `(,name (filename . ,(expand-file-name it)))))
                       projectile-known-projects))))

            (setq ibuffer-saved-filter-groups
                  (list
                   (cons "default"
                         (append
                          (ck/define-projectile-filter-groups)
                          '(("dired" (mode . dired-mode))
                            ("Org" (or
                                    (mode . org-mode)))
                            ("emacs" (or
                                      (name . "^\\*scratch\\*$")
                                      (name . "^\\*Messages\\*$")
                                      (name . "^\\*Help\\*$")
                                      (name . "^\\*Flycheck error messages\\*$")))
                            ("Gnus" (or
                                     (mode . message-mode)
                                     (mode . bbdb-mode)
                                     (mode . mail-mode)
                                     (mode . gnus-group-mode)
                                     (mode . gnus-summary-mode)
                                     (mode . gnus-article-mode)
                                     (name . "^\\.bbdb$")
                                     (name . "^\\.newsrc-dribble")))
                            ("Circe" (or
                                      (mode . circe-channel-mode)
                                      (mode . circe-query-mode)
                                      (mode . circe-mode)
                                      (mode . circe-server-mode))))))))

            (add-hook 'ibuffer-mode-hook
                      (lambda ()
                        (ibuffer-switch-to-saved-filter-groups "default")))
            (setq ibuffer-show-empty-filter-groups nil)))
#+end_src

** magit

   [[https://github.com/magit/magit][Magit]] is an Emacs git integration. I use it all the time, it rocks.

#+begin_src emacs-lisp
  (use-package magit
    :commands magit-status
    :init (progn
            (when (ck/is-osx)
              (setq magit-git-executable "/usr/local/bin/git")
              (setq magit-emacsclient-executable "/usr/local/bin/emacsclient")))
    :config (progn
              (add-to-list 'magit-no-confirm 'stage-all-changes)
              (setq magit-push-always-verify nil)
              (setq magit-last-seen-setup-instructions "2.1.0")))
#+end_src

** mail-mode

   Just a few modifications such as colors and such.

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("mutt-" . mail-mode))
(add-to-list 'auto-mode-alist '("kmail" . mail-mode))
(add-to-list 'auto-mode-alist '(".eml" . mail-mode))


(defface mail-double-quoted-text-face
  '((((class color)) :foreground "SteelBlue")) "Double-quoted email.")
(defface mail-treble-quoted-text-face
  '((((class color)) :foreground "SlateGrey")) "Treble-quoted email.")
(defface mail-multiply-quoted-text-face
  '((((class color)) :foreground "DarkSlateGrey")) "Multiply-quoted email.")

(font-lock-add-keywords 'mail-mode
                        '(("^\\(\\( *>\\)\\{4,\\}\\)\\(.*\\)$"
                           (1 'font-lock-comment-delimiter-face)
                           (3 'mail-multiply-quoted-text-face))
                          ("^\\(\\( *>\\)\\{3\\}\\)\\(.*\\)$"
                           (1 'font-lock-comment-delimiter-face)
                           (3 'mail-treble-quoted-text-face))
                          ("^\\( *> *>\\)\\(.*\\)$"
                           (1 'font-lock-comment-delimiter-face)
                           (2 'mail-double-quoted-text-face))))

(add-hook 'mail-mode-hook 'turn-on-auto-fill)
#+end_src

** markdown support

   Editing markdown in fundamental or text-mode sucks.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :commands markdown-mode
    :init (progn
            (add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
            (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))))
#+end_src

** multiple-cursor

   [[https://github.com/magnars/multiple-cursors.el][Oh the niceness…]] this is one of my most-often used features. It rocks!

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :commands mc/edit-lines mc/mark-next-like-this mc/mark-previous-like-this mc/mark-all-like-this
    :init (progn
            (define-key ck/keys-minor-mode-map "\C-ccm"
              (defhydra multicursor (:color red)
                "multicursor"
                ("v" mc/edit-lines "all lines")
                ("d" mc/mark-next-like-this "next match")
                ("p" mc/mark-previous-like-this "prev match")
                ("D" mc/mark-all-like-this "all matches")))))
#+end_src

** Perl support

   There seem to be references to =cperl-mode= in various pieces of
   code. We don't use it.

#+begin_src
(defalias 'perl-mode 'cperl-mode)
#+end_src

** PHP support

   Just indentation, nothing special.

#+begin_src emacs-lisp
  (use-package php-mode
    :commands php-mode
    :init (progn
            (defun ck-init-php ()
              (setq c-basic-offset 2)
              (c-set-offset 'arglist-cont 0)
              (c-set-offset 'arglist-intro 2)
              (c-set-offset 'case-label 2)
              (c-set-offset 'arglist-close 0))

            (add-hook 'php-mode-hook 'ck-init-php)))
#+end_src

** Rails integration

   We use RVM (and thus =rvm-mode=) and =projectile-rails=.

#+begin_src emacs-lisp
  (use-package rvm
    :commands rvm-use-default
    :init (progn
            (setq rvm--current-ruby nil)
            (add-hook 'ruby-mode-hook (lambda ()
                                        (interactive)
                                        (when (not rvm--current-ruby)
                                          (rvm-use-default))))))

  (use-package projectile-rails
    :commands projectile-rails-on
    :init
    (add-hook 'projectile-mode-hook 'projectile-rails-on))

  (defun get-current-test-name ()
    (save-excursion
      (let ((pos)
            (test-name))
        (re-search-backward "test \"\\([^\"]+\\)\" do")
        (setq test-name (buffer-substring-no-properties (match-beginning 1) (match-end 1)))
        (concat "test_" (replace-regexp-in-string " " "_" test-name)))))


  (defun run-test-at-point ()
    (interactive)
    (let ((root-dir (projectile-project-root)))
      (compile (format "ruby -Ilib:test -I%s/test %s -n %s" root-dir (expand-file-name (buffer-file-name)) (get-current-test-name)))))

  (defun run-test-file ()
    (interactive)
    (let ((root-dir (projectile-project-root))
          (filename (expand-file-name (buffer-file-name))))
      (setq filename (replace-regexp-in-string root-dir "" filename))
      (compile (format "rake test %s" filename))))

  (defun run-test-suite ()
    (interactive)
    (compile "rake test"))
#+end_src

** rainbow-delimiters

   [[https://github.com/jlr/rainbow-delimiters][Rainbow delimiters]] is a “rainbow parentheses”-like mode which
   highlights parentheses, brackets, and braces according to their
   depth. Each successive level is highlighted in a different
   color. This makes it easy to spot matching delimiters, orient
   yourself in the code, and tell which statements are at a given
   depth.

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :init
  (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+end_src

** ruby support

   Mainly =auto-mode-alist= and indentation.

#+begin_src emacs-lisp
  (use-package ruby-mode
    :commands ruby-mode
    :init (progn
            (add-hook 'ruby-mode-hook 'turn-on-font-lock)
            (add-hook 'ruby-mode-hook (lambda ()
                                        (setq tab-width 2
                                              indent-tabs-mode nil
                                          ;ruby-deep-arglist nil
                                          ;ruby-deep-indent-paren nil
                                              ruby-insert-encoding-magic-comment nil)))

            (add-to-list 'auto-mode-alist '("\\.rb$" . ruby-mode))
            (add-to-list 'auto-mode-alist '("\\.rake$" . ruby-mode))
            (add-to-list 'auto-mode-alist '("Rakefile$" . ruby-mode))
            (add-to-list 'auto-mode-alist '("\\.gemspec$" . ruby-mode))
            (add-to-list 'auto-mode-alist '("\\.ru$" . ruby-mode))
            (add-to-list 'auto-mode-alist '("Gemfile$" . ruby-mode))
            (add-to-list 'auto-mode-alist '("\\.prawn$" . ruby-mode))
            (add-to-list 'auto-mode-alist '("\\.xlsx\\.axlsx$" . ruby-mode))

            (define-key ck/keys-minor-mode-map (kbd "C-c r r") 'inf-ruby)

            (require 'ruby-hash-syntax)

            (define-key ck/keys-minor-mode-map "\C-ccr"
                (defhydra tests (:color red)
                  "Ruby"
                  ("h" ruby-toggle-hash-syntax "Toggle ruby Hash syntax")))

            (defadvice ruby-indent-line (after line-up-args activate)
              (let (indent prev-indent arg-indent)
                (save-excursion
                  (back-to-indentation)
                  (when (zerop (car (syntax-ppss)))
                    (setq indent (current-column))
                    (skip-chars-backward " \t\n")
                    (when (eq ?, (char-before))
                      (ruby-backward-sexp)
                      (back-to-indentation)
                      (setq prev-indent (current-column))
                      (skip-syntax-forward "w_.")
                      (skip-chars-forward " ")
                      (setq arg-indent (+ (ruby-current-indentation) ruby-indent-level))))) ;; (current-column)
                (when prev-indent
                  (let ((offset (- (current-column) indent)))
                    (cond ((< indent prev-indent)
                           (indent-line-to prev-indent))
                          ((= indent prev-indent)
                           (indent-line-to arg-indent)))
                    (when (> offset 0) (forward-char offset))))))))
#+end_src

** Rust support

#+begin_src emacs-lisp
  (use-package rust-mode
    :commands rust-mode
    :init (progn
            (setq rust-indent-unit 2)
            (setq-default rust-indent-unit 2)))
#+end_src

** SCSS mode

#+begin_src emacs-lisp
  (use-package scss-mode
    :commands scss-mode
    :init (progn
            (add-to-list 'auto-mode-alist '("\\.scss\\'" . scss-mode))

            (setq-default scss-compile-at-save nil)
            (setq-default css-indent-offset 2)))
#+end_src

** smart-mode-line

   Unclutters my mode line (e.g. hides minor modes).

#+begin_src emacs-lisp
  (use-package smart-mode-line
    :commands smart-mode-line
    :init (progn
            ;;(setq sml/theme 'light)
            (if after-init-time (sml/setup)
              (add-hook 'after-init-hook 'sml/setup)))

    :config (progn
              (custom-set-variables
               '(sml/hidden-modes (quote (" hl-p" " Helm" " Guide" " ck/keys" " pair" " HRB" " AC" " GitGutter" " FlyC" " FlyC-" " MMM" " Rails" " yas" " SP" " WS" " MRev"))))

              (add-to-list 'sml/replacer-regexp-list '("^~/\\(data/\\)?[Ss]ites/" ":WEB:"))
              (add-to-list 'sml/replacer-regexp-list '("^~/\\(data/\\)?dev/" ":DEV:"))
              (add-to-list 'sml/replacer-regexp-list '("^~/\\(data/\\)?dev/postgres/" ":PG:"))
              (add-to-list 'sml/replacer-regexp-list '("^~/\\(data/\\)?Documents/" ":DOC:"))))
#+end_src

** SQL

#+begin_src emacs-lisp
  (add-hook 'sql-interactive-mode-hook
            (lambda ()
              (toggle-truncate-lines t)))

  (add-hook 'sql-mode-hook 'sqlup-mode)
  (add-hook 'sql-interactive-mode-hook 'sqlup-mode)

  (define-key ck/keys-minor-mode-map (kbd "C-c u") 'sqlup-capitalize-keywords-in-region)

  (defun sql-indent-string ()
    "Indents the string under the cursor as SQL."
    (interactive)
    (save-excursion
      (er/mark-inside-quotes)
      (let* ((text (buffer-substring-no-properties (region-beginning) (region-end)))
             (pos (region-beginning))
             (column (progn (goto-char pos) (current-column)))
             (formatted-text (with-temp-buffer
                               (insert text)
                               (delete-trailing-whitespace)
                               (sql-indent-buffer)
                               (replace-string "\n" (concat "\n" (make-string column (string-to-char " "))) nil (point-min) (point-max))
                               (buffer-string))))
        (delete-region (region-beginning) (region-end))
        (goto-char pos)
        (insert formatted-text))))
#+end_src

** Swift support

#+begin_src emacs-lisp
  (use-package swift-mode
    :commands swift-mode
    :init
    (setq swift-indent-offset 2))
#+end_src

** JavaScript

#+begin_src emacs-lisp
  (use-package js2-mode
    :commands js2-mode
    :init (progn
            (add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
            (add-to-list 'interpreter-mode-alist '("node" . js2-mode))
            (custom-set-variables
             '(js2-basic-offset 2))))
#+end_src

** which-function-mode

   This little mode displays the function the point is currently
   located in in the mode line.

#+begin_src emacs-lisp
(which-function-mode)

(add-to-list 'which-func-modes 'ruby-mode)
(add-to-list 'which-func-modes 'emacs-lisp-mode)
(add-to-list 'which-func-modes 'js-mode)
(add-to-list 'which-func-modes 'c-mode)
(add-to-list 'which-func-modes 'php-mode)
#+end_src

** whitespace-mode

#+begin_src emacs-lisp
  (use-package whitespace
    :init (progn
            (setq whitespace-global-modes '(c-mode c++-mode ruby-mode web-mode php-mode js2-mode css-mode scss-mode))
            (global-whitespace-mode t)
            (setq show-trailing-whitespace t)
            (setq whitespace-style '(face trailing))))
#+end_src

** YAML support

#+begin_src emacs-lisp
(use-package yaml-mode
  :commands yaml-mode
  :init
  (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode)))
#+end_src

** easy gists

#+begin_src emacs-lisp
(use-package gist
  :commands gist-region gist-region-private gist-buffer gist-buffer-private gist-region-or-buffer gist-region-or-buffer-private)
#+end_src

** =dired= customizations

First we want some nice little extra functions for =dired=

#+begin_src emacs-lisp
(require 'dired-x)
#+end_src

When using OS X, the =ls= doesn't support =--dired=

#+begin_src emacs-lisp
(when (ck/is-osx)
  (setq dired-use-ls-dired nil))
#+end_src

** Kill line with universal prefix

   This macro provides the following functionality:
   - when pressing C-k I get the original C-k behavior
   - when pressing C-<n> C-k (where n is a numeric prefix) I kill the complete current + (n-1) lines

   The idea is shamelessly stolen from [[http://endlessparentheses.com/kill-entire-line-with-prefix-argument.html][Endless Parenthesis]]

#+begin_src emacs-lisp
(defmacro bol-with-prefix (function)
  "Define a new function which calls FUNCTION.
Except it moves to beginning of line before calling FUNCTION when
called with a prefix argument. The FUNCTION still receives the
prefix argument."
  (let ((name (intern (format "endless/%s-BOL" function))))
    `(progn
       (defun ,name (p)
         ,(format 
           "Call `%s', but move to BOL when called with a prefix argument."
           function)
         (interactive "P")
         (when p
           (forward-line 0))
         (call-interactively ',function))
       ',name)))

(global-set-key [remap paredit-kill] (bol-with-prefix paredit-kill))
(global-set-key [remap org-kill-line] (bol-with-prefix org-kill-line))
(global-set-key [remap kill-line] (bol-with-prefix kill-line))
#+end_src

** Launcher map for not-so-often used tools

   Tools I don't use that often get its own launcher map so I remember
   them easily.

#+begin_src emacs-lisp
  (define-key ck/keys-minor-mode-map "\C-ccl"
    (if (ck/is-osx)
        (defhydra launchers (:color blue)
          "Launchers"
          ("c" calc "Calc")
          ("d" ediff-buffers "ediff")
          ("f" find-dired "find-dired")
          ("g" lgrep "lgrep")
          ("G" rgrep "rgrep")
          ("h" man "man")
          ("s" eshell-here "eshell")
          ("t" proced "proced")
          ("a" magit-status "magit-status")
          ("p" sql-postgres "sql-postgres"))
      (defhydra launchers (:color blue)
        "Launchers"
        ("c" calc "Calc")
        ("d" ediff-buffers "ediff")
        ("f" find-dired "find-dired")
        ("g" lgrep "lgrep")
        ("G" rgrep "rgrep")
        ("h" man "man")
        ("s" eshell-here "eshell")
        ("t" proced "proced")
        ("a" magit-status "magit-status")
        ("p" sql-postgres "sql-postgres")
        ("u" (start-process "dump" "*dump*" "~/dev/mail/dump.sh") "dump tags")
        ("U" (start-process "restore" "*dump*" "~/dev/mail/restore.sh") "restore tags")
        ("z" (start-process "sync-mail" "*sync-mail*" "~/dev/mail/sync-mail") "sync mail"))))

#+end_src

** =eshell= modifications

#+begin_src emacs-lisp
  (defun eshell-here ()
    "Opens up a new shell in the directory associated with the
  current buffer's file. The eshell is renamed to match that
  directory to make multiple eshell windows easier."
    (interactive)
    (let* ((parent (if (buffer-file-name)
                       (file-name-directory (buffer-file-name))
                     default-directory))
           (height (/ (window-total-height) 3))
           (name   (car (last (split-string parent "/" t)))))
      (split-window-vertically (- height))
      (other-window 1)
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))))

  (defun eshell/x ()
    (interactive)
    (insert "exit")
    (eshell-send-input)
    (delete-window))

  (defun eshell-mode-hook-func ()
    (setq eshell-path-env (concat (getenv "PATH") ":" eshell-path-env))
    (define-key eshell-mode-map [up] 'previous-line)
    (define-key eshell-mode-map [down] 'next-line)
    (define-key eshell-mode-map (kbd "\C-x k") 'eshell/x))
    ;(setenv "PATH" (concat "/usr/local/bin:" (getenv "PATH")))
    ;(define-key eshell-mode-map (kbd "M-s") 'other-window-or-split))

  (add-hook 'eshell-mode-hook 'eshell-mode-hook-func)

#+end_src
** =typo.el=, the library for typographics in Emacs

#+begin_src emacs-lisp
  (when (not (ck/is-osx))
    (use-package typo
      :commands typo-global-mode
      :init (progn
              (typo-global-mode 1)
              (add-hook 'text-mode-hook 'typo-mode)

              (add-hook 'circe-chat-mode-hook 'typo-mode)

              (setq typo-language "German")
              (setq-default typo-language "German"))))
#+end_src
** Circe, IRC over Emacs

#+begin_src emacs-lisp
  (when (not (ck/is-osx))
    (use-package circe
      :commands (circe circe-set-display-handler)
      :init (progn
              (defun ck/irc-login ()
                "Login into my usual IRCs."
                (interactive)
                (circe "EPD-ME")
                (circe "CCC")
                (circe "Freenode"))

              (load "~/dev/mail/znc.el"))

      :config (progn
                ;; (defun ck/circe-prompt ()
                ;;   (lui-set-prompt
                ;;    (concat (propertize (concat (buffer-name) ">")
                ;;                        'face 'circe-prompt-face)
                ;;            " ")))

                ;; (defun ck/circe-set-margin ()
                ;;   (setq
                ;;    fringes-outside-margins t
                ;;    right-margin-width 5
                ;;    word-wrap t
                ;;    wrap-prefix "    "))


                ;; (add-hook 'circe-chat-mode-hook 'ck/circe-prompt)
                ;; (add-hook 'lui-mode-hook 'ck/circe-set-margin)

                (require 'circe-color-nicks)
                (require 'circe-chanop)
                (require 'circe-notifications)

                (enable-circe-color-nicks)
                (defun lui-irc-propertize (&rest args))

                (defadvice circe-command-SAY (after jjf-circe-unignore-target)
                  (let ((ignored (tracking-ignored-p (current-buffer) nil)))
                    (when ignored
                      (setq tracking-ignored-buffers
                            (remove ignored tracking-ignored-buffers))
                      (message "This buffer will now be tracked."))))
                (ad-activate 'circe-command-SAY)

                (setq circe-reduce-lurker-spam t
                      ;; lui-time-stamp-position 'right-margin
                      lui-time-stamp-format "%H:%M"
                      lui-fill-column 120
                      ;; lui-fill-type nil
                      circe-network-options `(
                                              ("EPD-ME"
                                               :nick "Christian"
                                               :host "jugulator.defunced.de"
                                               :service 6660
                                               :tls t
                                               :channels ("#selfhtml")
                                               :pass ,epdme-password)

                                              ("CCC"
                                               :nick "cjk101010"
                                               :host "jugulator.defunced.de"
                                               :service 6660
                                               :tls t
                                               :channels ("#ccc")
                                               :pass ,ccc-password)

                                              ("Freenode"
                                               :nick "cjk101010"
                                               :host "jugulator.defunced.de"
                                               :service 6660
                                               :tls t
                                               :channels ("#warpzone" "#postgresql" "#rubyonrails" "#erlang" "#emacs" "#ruby")
                                               :pass ,freenode-password))
                      tracking-ignored-buffers '("#postgresql" "#erlang" "#emacs" "#ruby"))

                (enable-circe-notifications))))
#+end_src

** edit-server

#+begin_src emacs-lisp
  (use-package edit-server
    :init (progn
            (setq edit-server-new-frame nil)
            (edit-server-start)))
#+end_src
** comment/uncomment line

#+begin_src emacs-lisp
  (defun endless/comment-line-or-region (n)
    "Comment or uncomment current line and leave point after it.
  With positive prefix, apply to N lines including current one.
  With negative prefix, apply to -N lines above.
  If region is active, apply to active region instead."
    (interactive "p")
    (if (use-region-p)
        (comment-or-uncomment-region
         (region-beginning) (region-end))
      (let ((range
             (list (line-beginning-position)
                   (goto-char (line-end-position n)))))
        (comment-or-uncomment-region
         (apply #'min range)
         (apply #'max range)))
      (forward-line 1)
      (back-to-indentation)))

  (define-key ck/keys-minor-mode-map (kbd "C-c c C-c") 'endless/comment-line-or-region)
#+end_src

** =mmm-mode=

#+begin_src emacs-lisp
  (use-package mmm-mode
    :config (progn
              (setq mmm-global-mode 'maybe)
              (set-face-background 'mmm-default-submode-face nil)

              (mmm-add-classes
               '((embedded-sql
                  :submode sql-mode
                  :front "<<-?SQL"
                  :front-offset (end-of-line 1)
                  :back "^[ \t]*SQL$"
                  :delimiter-mode nil)))

              (mmm-add-mode-ext-class 'ruby-mode nil 'embedded-sql)
              (setq mmm-never-modes
                    (append '(ediff-mode) '(text-mode) mmm-never-modes))))
#+end_src

** go-mode

#+begin_src emacs-lisp
  (use-package go-mode
    :commands go-mode
    :init (progn
            (add-to-list 'exec-path (concat (getenv "HOME") "/dev/go/bin"))
            (add-to-list 'auto-mode-alist (cons "\\.go\\'" 'go-mode))
            (add-hook 'before-save-hook #'gofmt-before-save)
            (setenv "GOPATH" (concat (getenv "HOME") "/dev/go")))
    :config (progn
              (require 'go-autocomplete)))
#+end_src

** elixir-mode

#+begin_src emacs-lisp
  (use-package elixir-mode
    :commands elixir-mode
    :config (progn
              (alchemist-mode)))
#+end_src

** alchemist

#+begin_src emacs-lisp
  (use-package alchemist
    :commands alchemist-mode alchemist-iex-run alchemist-iex-project-run
    :config (progn
              (setq alchemist-project-compile-when-needed t
                    alchemist-complete-debug-mode nil
                    alchemist-hooks-test-on-save t)))
#+end_src

** helm

#+begin_src emacs-lisp
  (use-package helm-config
    :config (progn
              (setq helm-split-window-in-side-p t
                    helm-move-to-line-cycle-in-source t
                    helm-ff-search-library-in-sexp t
                    helm-scroll-amount 8
                    helm-mode-fuzzy-match t
                    helm-buffers-fuzzy-matching t)

              (setq helm-autoresize-max-height 30
                    helm-autoresize-min-height 30)

              (helm-mode 1)

              (setq helm-completing-read-handlers-alist '((describe-function . helm-completing-read-symbols)
                                                          (describe-variable . helm-completing-read-symbols)
                                                          (describe-symbol . helm-completing-read-symbols)
                                                          (debug-on-entry . helm-completing-read-symbols)
                                                          (find-function . helm-completing-read-symbols)
                                                          (disassemble . helm-completing-read-symbols)
                                                          (trace-function . helm-completing-read-symbols)
                                                          (trace-function-foreground . helm-completing-read-symbols)
                                                          (trace-function-background . helm-completing-read-symbols)
                                                          (find-tag . helm-completing-read-with-cands-in-buffer)
                                                          (ffap-alternate-file)
                                                          (tmm-menubar)))

              (helm-autoresize-mode t)

              (global-set-key (kbd "M-y") 'helm-show-kill-ring)
              (global-set-key (kbd "C-x b") 'helm-mini)

              (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
              (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
              (define-key helm-map (kbd "C-z")  'helm-select-action)

              (use-package helm-projectile
                :init (progn
                        (helm-projectile-on)))))

#+end_src

** helm-dash

#+begin_src emacs-lisp
  (when (not (ck/is-osx))
    (use-package helm-dash
      :commands helm-dash helm-dash-at-point
      :init (progn
              (define-key ck/keys-minor-mode-map [f1] 'helm-dash-at-point)

              (setq helm-dash-common-docsets '("HTML" "CSS" "Bootstrap 4" "JavaScript"
                                               "jQuery" "Ruby on Rails" "Ruby" "Go"
                                               "C" "C++" "Elixir")))))
#+end_src
** puppet

#+begin_src emacs-lisp
(use-package puppet-mode)
#+end_src
** voilatile highlights

#+begin_src emacs-lisp
  (use-package volatile-highlights
    :config (progn
              (volatile-highlights-mode t)
              (custom-set-faces
               '(vhl/default-face ((t (:background "#515151" :foreground "#99cc99")))))
              (setq Vhl/highlight-zero-width-ranges t)))
#+end_src

